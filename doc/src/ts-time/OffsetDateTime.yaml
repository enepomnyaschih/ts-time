# MIT License
#
# Copyright (c) 2019-2022 Egor Nepomnyaschih
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

symbols:
  default:
    kind: class
    description: |
      <p>Comprises a specific instant bound to a specific time zone offset. In other words, this is a tuple of
      (%Instant, %ZoneOffset). Unambiguously identifies a %LocalDateTime.</p>
    topics:
      construct:
        header: Construct
        text: |
          <p>%OffsetDateTime has a very limited number of usage scenarios, so it has a limited number of ways to be
          constructed to avoid its misuse. Always consider using other data structures (%ZonedDateTime, %LocalDateTime,
          %Instant) before %OffsetDateTime.</p>
          <p>Typically you don't construct %OffsetDateTime directly, but create it from other data structures:</p>
          <pre>
          %OffsetDateTime.%ofInstant(instant, offset);   // From %Instant in a given %ZoneOffset
          instant.%atOffsetOfInstant(offset);                    // Equivalent
          %OffsetDateTime.%ofDateTime(dateTime, offset); // From %LocalDateTime in a given %ZoneOffset
          dateTime.%atOffsetOfDateTime(offset);                   // Equivalent
          zonedDateTime.%offsetDateTime;                // From %ZonedDateTime
          </pre>
          <p>Please notice that:</p>
          <ul>
          <li>Conversion from %Instant may be counter-intuitive, as string presentation of the date/time may change:
          <pre>
          const offset  = %ZoneOffset.%ofComponentsOfOffset(-2);
          const instant = %Instant.%parseOfInstant("2022-06-14T00:00:00.000Z");
          console.log(instant.%atOffsetOfInstant(offset));           // "2022-06-13T22:00:00.000-02:00"
          </pre>
          It happens, because %OffsetDateTime preserves its %instant component in this case, not %dateTime:
          <pre>
          console.log(instant.%atOffsetOfInstant(offset).%instant);   // "2022-06-14T00:00:00.000Z"
          console.log(instant.%atOffsetOfInstant(offset).%dateTime);  // "2022-06-13T22:00:00.000"
          </pre></li>
          <li>Conversion from %LocalDateTime, on the contrary, preserves %dateTime component:
          <pre>
          const dateTime = %LocalDateTime.%parseOfDateTime("2022-06-14T00:00:00.000");
          console.log(dateTime.%atOffsetOfDateTime(offset));          // "2022-06-14T00:00:00.000-02:00"
          console.log(dateTime.%atOffsetOfDateTime(offset).%dateTime); // "2022-06-14T00:00:00.000"
          console.log(dateTime.%atOffsetOfDateTime(offset).%instant);  // "2022-06-14T02:00:00.000Z"
          </pre></li>
          <li>Conversion from %ZonedDateTime may result in a partial data loss (if the time zone has dynamic offset).</li>
          </ul>
        references:
          parseOfInstant:
            file: ts-time/Instant
            member: parse
            static: true
            label: parse
          parseOfDateTime:
            file: ts-time/LocalDateTime
            member: parse
            static: true
            label: parse
          atOffsetOfInstant:
            file: ts-time/Instant
            member: atOffset
            label: atOffset
          atOffsetOfDateTime:
            file: ts-time/LocalDateTime
            member: atOffset
            label: atOffset
          offsetDateTime:
            file: ts-time/ZonedDateTime
            member: offsetDateTime
          ofComponentsOfOffset:
            file: ts-time/Zone
            symbol: ZoneOffset
            member: ofComponents
            static: true
            label: ofComponents

      parse:
        header: Parse
        text: |
          <p>A common way to parse an ISO 8601 compliant string in ts-time is to call %parse static method. For example,
          the following %OffsetDateTime instance represents 18 hours, 30 minutes, 15 seconds, 225 milliseconds on
          15th of February, 2022, UTC-2 offset:</p></p>
          <pre>
          %OffsetDateTime.%parse("2022-02-15T18:30:15.225-02:00");
          </pre>
          <p class="text-danger">The library doesn't yet support parsing non-compliant strings.</p>
        references:
          parse:
            file: ts-time/OffsetDateTime
            member: parse
            static: true

      inspect:
        header: Inspect
        text: |
          <p>In the following example, we inspect various properties of a %OffsetDateTime object. Please notice
          the difference in return value types:</p>
          <pre>
          const offsetDateTime = %OffsetDateTime.%parse("2022-02-15T18:30:15.225-02:00");
          const year           = offsetDateTime.%year;            // 2022
          const month          = offsetDateTime.%month;           // %FEBRUARY
          const monthValue     = offsetDateTime.%month.%valueOfMonth;     // 2
          const dayOfMonth     = offsetDateTime.%dayOfMonth;      // 15
          const dayOfWeek      = offsetDateTime.%dayOfWeek;       // %TUESDAY
          const dayOfWeekValue = offsetDateTime.%dayOfWeek.%valueOfDay; // 2
          const hour           = offsetDateTime.%hour;            // 18
          const minute         = offsetDateTime.%minute;          // 30
          const second         = offsetDateTime.%second;          // 15
          const ms             = offsetDateTime.%ms;              // 225
          const offset         = offsetDateTime.%offset;          // Instance of %ZoneOffset
          const offsetHours    = offsetDateTime.%offset.%hours;    // -2
          const offsetMinutes  = offsetDateTime.%offset.%minutes;  // 0
          const offsetSeconds  = offsetDateTime.%offset.%seconds;  // 0
          </pre>
          <p>Other sophisticated features for %OffsetDateTime inspection: %epochMs, %era, %yearOfEra, %weekBasedYear,
          %weekOfWeekBasedYear, %dayOfYear, %dayOfWeekBasedYear, %epochDay, %quarterOfYear, %isLeapYear,
          %lengthOfYear.</p>
        references:
          valueOfMonth:
            file: ts-time/Month
            member: value
            label: value
          valueOfDay:
            file: ts-time/DayOfWeek
            member: value
            label: value
          hours:
            file: ts-time/Zone
            symbol: ZoneOffset
            member: hours
          minutes:
            file: ts-time/Zone
            symbol: ZoneOffset
            member: minutes
          seconds:
            file: ts-time/Zone
            symbol: ZoneOffset
            member: seconds

      compare:
        header: Compare
        text: |
          <p>A common way to compare objects in ts-time is to call %equals, %compareTo methods:</p>
          <pre>
          const d1 = %OffsetDateTime.%parse("2022-02-15T18:30:15.225-02:00");
          const d2 = %OffsetDateTime.%parse("2022-02-15T18:30:15.226-02:00");
          d1.%equals(d2);    // false
          d1.%compareTo(d2); // -1
          </pre>
          <p>The objects are first compared by %instant, and then by %offset.</p>
          <p>For nullable objects, use static methods instead. Null and undefined are considered less than anything,
          except each other:</p>
          <pre>
          const d1: %OffsetDateTime = null;
          const d2 = %OffsetDateTime.%parse("2022-02-15T18:30:15.226-02:00");
          %OffsetDateTime.%equal(d1, d2);   // false
          %OffsetDateTime.%compare(d1, d2); // -1
          </pre>
          <p>As opposed to the majority of objects in ts-time, %OffsetDateTime doesn't have <b>isBefore</b> and
          <b>isAfter</b> methods. You must explicitly specify which component you want to compare: %instant or
          %dateTime.</p>
          <pre>
          const d1 = %OffsetDateTime.%parse("2022-02-15T18:30:15.225-05:00");
          const d2 = %OffsetDateTime.%parse("2022-02-15T20:30:15.226+01:00");
          d1.%instant.%isBeforeOfInstant(d2.%instant);   // false
          d1.%dateTime.%isBeforeOfDateTime(d2.%dateTime); // true
          </pre>
        references:
          isBeforeOfInstant:
            file: ts-time/Instant
            member: isBefore
            label: isBefore
          isBeforeOfDateTime:
            file: ts-time/LocalDateTime
            member: isBefore
            label: isBefore
          compare:
            file: ts-time/OffsetDateTime
            member: compare
            static: true

      manipulation:
        header: Manipulate
        text: |
          <p>Every object in ts-time is immutable. Therefore every manipulation returns a new object.</p>
          <p>To add/subtract a %Period, call %plusPeriod/%minusPeriod method:</p>
          <pre>
          const offsetDateTime = %OffsetDateTime.%parse("2022-02-15T18:30:15.225-02:00");
          const d1 = offsetDateTime.%plusPeriod(%DAY_PERIOD);                // 18:30:15.225 on 16th of February, 2022, UTC-2
          const d2 = offsetDateTime.%plusPeriod(%Period.%ofDays(2));          // 18:30:15.225 on 17th of February, 2022, UTC-2
          const d3 = offsetDateTime.%minusPeriod(%MONTH_PERIOD);             // 18:30:15.225 on 15th of January, 2022, UTC-2
          </pre>
          <p>The algorithm respects %dateTime to align periods, not %instant. In the following example, offsetDateTime
          is the 1st of March in UTC+2, but still 28th of February in UTC. When adding a month, the library considers
          offsetDateTime to be the 1st of March, so it adds 31 days, not 28:</p>
          <pre>
          const offsetDateTime = %OffsetDateTime.%parse("2022-03-01T00:00:00.000+02:00");
          const d1 = offsetDateTime.%plusPeriod(%MONTH_PERIOD);              // Midnight on 1st of April, 2022, UTC+2
          </pre>
          <p>If you expect a month to be added in %UTC, convert the %instant explicitly to %UTC first:</p>
          <pre>
          const d2 = offsetDateTime.%instant.%atOffset(%UTC).%plusPeriod(%MONTH_PERIOD); // 22:00 on 28th of March, 2022, UTC
          </pre>
          <p>To add/subtract a %Duration, call %plusDuration/%minusDuration method:</p>
          <pre>
          const offsetDateTime = %OffsetDateTime.%parse("2022-02-15T18:30:15.225-02:00");
          const d1 = offsetDateTime.%plusDuration(%MINUTE_DURATION);         // 18:31:15.225 on 15th of February, 2022, UTC-2
          const d2 = offsetDateTime.%plusDuration(%Duration.%ofHours(10));    // 04:30:15.225 on 16th of February, 2022, UTC-2
          const d3 = offsetDateTime.%minusDuration(%Duration.%ofSeconds(30)); // 18:29:45.225 on 15th of February, 2022, UTC-2
          </pre>
          <p>For difference between %Period and %Duration, see their documentation. For %OffsetDateTime, they are
          interchangeable - apart for the list of supported date/time components.</p>
          <p>To change one of the components, preserving all the rest, call <b>with*</b> methods:</p>
          <pre>
          const offsetDateTime = %OffsetDateTime.%parse("2022-02-15T18:30:15.225-02:00");
          const d1 = offsetDateTime.%withYear(2025);                        // 18:30:15.225 on 15th of February, 2025, UTC-2
          const d2 = offsetDateTime.%withMonth(%APRIL);                      // 18:30:15.225 on 15th of April, 2022, UTC-2
          const d3 = offsetDateTime.%withDayOfMonth(10);                    // 18:30:15.225 on 10th of February, 2022, UTC-2
          const d4 = offsetDateTime.%withDayOfWeek(%SUNDAY);                 // 18:30:15.225 on 20th of February, 2022, Sunday, UTC-2
          const d5 = offsetDateTime.%withHour(20);                          // 20:30:15.225 on 15th of February, 2022, UTC-2
          const d6 = offsetDateTime.%withMinute(20);                        // 18:20:15.225 on 15th of February, 2022, UTC-2
          const d7 = offsetDateTime.%withSecond(20);                        // 18:30:20.225 on 15th of February, 2022, UTC-2
          const d8 = offsetDateTime.%withMs(20);                            // 18:30:15.020 on 15th of February, 2022, UTC-2
          </pre>
          <p>For manipulating %offset component, see %convert.</p>
          <p><span class="text-danger">The library doesn't yet support %OffsetDateTime truncating.</span> Truncate its
          %dateTime component instead.</p>
          <p>Another sophisticated feature for %OffsetDateTime manipulation: %withDayOfYear.</p>
        references:
          atOffset:
            file: ts-time/Instant
            member: atOffset
          ofHours:
            file: ts-time/Duration
            member: ofHours
            static: true
          ofSeconds:
            file: ts-time/Duration
            member: ofSeconds
            static: true
          ofDays:
            file: ts-time/Period
            member: ofDays
            static: true
          valueOfDayOfWeek:
            file: ts-time/DayOfWeek
            member: value
            label: value
          convert:
            href: '#conversion'
            label: Convert

      conversion:
        header: Convert
        text: |
          <p>You can convert %OffsetDateTime to other kinds of objects via its properties:</p>
          <pre>
          const offsetDateTime = %OffsetDateTime.%parse("2022-02-15T18:30:15.225-02:00");
          offsetDateTime.%instant;                   // To %Instant: 2022-02-15T20:30:15.225Z
          offsetDateTime.%date;                      // To %LocalDate: 2022-02-15
          offsetDateTime.%time;                      // To %LocalTime: 18:30:15.225
          offsetDateTime.%dateTime;                  // To %LocalDateTime: 2022-02-15T18:30:15.225
          offsetDateTime.%instant.%atOffsetOfInstant(offset);  // To %OffsetDateTime with another %ZoneOffset, preserving %instant component: 2022-02-16T00:30:15.225+04:00
          offsetDateTime.%dateTime.%atOffsetOfDateTime(offset); // To %OffsetDateTime with another %ZoneOffset, preserving %dateTime component: 2022-02-15T18:30:15.225+04:00
          offsetDateTime.%instant.%atZoneOfInstant(zone);      // To %ZonedDateTime in a given %ZoneId, preserving %instant component: 2022-02-15T20:30:15.225Z
          offsetDateTime.%dateTime.%atZoneOfDateTime(zone);     // To %ZonedDateTime in a given %ZoneId, preserving %dateTime component: 2022-02-15T18:30:15.225Z
          </pre>
          <p>Please notice that all conversions result in a partial data loss (date, time, original offset).</p>
          <p>You can as well convert %OffsetDateTime to a native JavaScript %Date:</p>
          <pre>
          const offsetDateTime = %OffsetDateTime.%parse("2022-02-15T18:30:15.225-02:00");
          offsetDateTime.%native;                    // Date representing 20:30:15.225 on 15th of February, 2022 (UTC)
          </pre>
          <p>Please notice that native %Date is always stored in UTC or local time zone, so you can see a different
          date/time when printing it as a string. It will be the same instant, just a different time zone.</p>
          <p>For backward conversion, see %construct.</p>
        references:
          atOffsetOfInstant:
            file: ts-time/Instant
            member: atOffset
            label: atOffset
          atOffsetOfDateTime:
            file: ts-time/LocalDateTime
            member: atOffset
            label: atOffset
          atZoneOfInstant:
            file: ts-time/Instant
            member: atZone
            label: atZone
          atZoneOfDateTime:
            file: ts-time/LocalDateTime
            member: atZone
            label: atZone
          construct:
            href: '#construct'
            label: Construct

      format:
        header: Format
        text: |
          <p>Every class in ts-time has ISO 8601 compliant %toString method:</p>
          <pre>
          const offsetDateTime = %OffsetDateTime.%parse("2022-02-15T18:30:15.225-02:00");
          offsetDateTime.%toString(); // "2022-02-15T18:30:15.225-02:00"
          </pre>
          <p>For more sophisticated string formatting, add %tsTimeFormat library to your list of dependencies:</p>
          <pre>
          npm install --save %tsTimeFormat
          </pre>
          <p>Now you can construct an instance of %OffsetDateTimeFormatter in order to format arbitrary %OffsetDateTime
          instances:</p>
          <pre>
          const formatter = %OffsetDateTimeFormatter.%ofPattern("dd.MMM''yy, hh:mm a ('UTC'x)");
          const offsetDateTime = %OffsetDateTime.%parse("2022-02-15T18:30:15.225-02:00");
          formatter.%format(offsetDateTime); // "15.Feb'22, 06:30 PM (UTC-02)"
          </pre>
          <p>You can define a custom %context object to internationalize the formatted strings:</p>
          <pre>
          const context = {monthShortNames: ["Янв", "Фев", "Мар"]};
          formatter.%format(offsetDateTime, context); // "15.Фев'22, 06:30 PM (UTC-02)"
          </pre>
        references:
          toString:
            file: ts-time/OffsetDateTime
            member: toString
          ofPattern:
            file: ts-time-format/OffsetDateTimeFormatter
            member: ofPattern
            static: true
          format:
            file: ts-time-format/OffsetDateTimeFormatter
            member: format
          context:
            file: ts-time-format/constants
            symbol: DEFAULT_TEMPORAL_CONTEXT

    properties:
      dateTime:
        modifiers: readonly
        type: '%LocalDateTime'
        description: Date/time representing %instant in %offset.

      instant:
        modifiers: readonly
        type: '%Instant'
        description: Instant representing %dateTime in %offset.

      offset:
        modifiers: readonly
        type: '%ZoneOffset'
        description: Time zone offset. Connection between %instant and %dateTime.

      date:
        modifiers: readonly
        type: '%LocalDate'
        description: Date part.

      time:
        modifiers: readonly
        type: '%LocalTime'
        description: Time part.

      native:
        modifiers: readonly
        type: Date
        description: Native JS Date representing %instant, for compatibility with native and third party API.

      epochMs:
        modifiers: readonly
        type: number
        description: Number of milliseconds since epoch.

      era:
        modifiers: readonly
        type: '%Era'
        description: Era.

      year:
        modifiers: readonly
        type: number
        description: Absolute year.

      yearOfEra:
        modifiers: readonly
        type: number
        description: Year in %era. See %Era for details.

      weekBasedYear:
        modifiers: readonly
        type: number
        description: Absolute week based year. %%weekBased

      month:
        modifiers: readonly
        type: '%Month'
        description: Month.

      weekOfWeekBasedYear:
        modifiers: readonly
        type: number
        description: 1-based week of week-based year. %%weekBased

      dayOfYear:
        modifiers: readonly
        type: number
        description: 1-based day of year.

      dayOfWeekBasedYear:
        modifiers: readonly
        type: number
        description: 1-based day of week-based year. %%weekBased

      dayOfMonth:
        modifiers: readonly
        type: number
        description: 1-based day of month.

      dayOfWeek:
        modifiers: readonly
        type: '%DayOfWeek'
        description: Day of week.

      epochDay:
        modifiers: readonly
        type: number
        description: 1-based day since epoch (i.e. 1st of %JANUARY 1970 is the 1st epoch day).

      quarterOfYear:
        modifiers: readonly
        type: number
        description: 1-based quarter of year.

      isLeapYear:
        modifiers: readonly
        type: boolean
        description: True if belongs to a leap year.

      lengthOfYear:
        modifiers: readonly
        type: number
        description: Number of days in year (365 for non-leap, 366 for leap).

      hour:
        modifiers: readonly
        type: number
        description: Hour of a day (0-23).

      minute:
        modifiers: readonly
        type: number
        description: Minute of an hour (0-59).

      second:
        modifiers: readonly
        type: number
        description: Second of a minute (0-59).

      ms:
        modifiers: readonly
        type: number
        description: Millisecond of a second (0-999).

    methods:
      compareTo:
        signature: |
          (other: %OffsetDateTime): number
        params:
          other: Offset date/time to compare to.
        returns: |
          <ul>
            <li>0 if this is the same offset date/time;</li>
            <li>positive value if this offset date/time goes after %other;</li>
            <li>negative value if this offset date/time goes before %other.</li>
          </ul>
          The objects are first compared by instant, and then by offset.
          Null and undefined are considered less than anything, except each other. %%null

      equals:
        signature: |
          (other: %OffsetDateTime): boolean
        params:
          other: Offset date/time to compare to.
        returns: |
          True if this offset date/time is equal to %other, i.e. all components are equal.
          Null and undefined are only equal to each other. %%null

      plusDuration:
        signature: |
          (duration: %Duration): %OffsetDateTime
        params:
          duration: '%Duration to add.'
        returns: New %OffsetDateTime shifted onwards from this one by the specified duration in the same %offset.

      plusPeriod:
        signature: |
          (period: %Period): %OffsetDateTime
        params:
          period: '%Period to add.'
        returns: |
          New %OffsetDateTime shifted onwards from this one by the specified period in the same %offset.
          The algorithm respects %dateTime to align periods.

      minusDuration:
        signature: |
          (duration: %Duration): %OffsetDateTime
        params:
          duration: '%Duration to subtract.'
        returns: New %OffsetDateTime shifted backwards from this one by the specified duration in the same %offset.

      minusPeriod:
        signature: |
          (period: %Period): %OffsetDateTime
        params:
          period: '%Period to subtract.'
        returns: |
          New %OffsetDateTime shifted backwards from this one by the specified period in the same %offset.
          The algorithm respects %dateTime to align periods.

      withYear:
        signature: |
          (year: number): %OffsetDateTime
        params:
          year: Absolute year.
        returns: |
          New %OffsetDateTime with the specified year and its current month/day of month/time/offset. If such date doesn't
          exist, it shifts the date back to the nearest valid one, preserving the time (e.g. 29th of %FEBRUARY in 2019,
          18:30, UTC+3 gets shifted to 28th of %FEBRUARY, 18:30, UTC+3).

      withMonth:
        signature: |
          (month: number | %Month): %OffsetDateTime
        params:
          month: Month.
        returns: |
          New %OffsetDateTime with the specified month and its current year/day of month/time/offset. If such date doesn't
          exist, it shifts the date back to the nearest valid one, preserving the time (e.g. 31st of %APRIL, 18:30, UTC+3 gets
          shifted to 30th of %APRIL, 18:30, UTC+3).

      withDayOfMonth:
        signature: |
          (dayOfMonth: number): %OffsetDateTime
        params:
          dayOfMonth: 1-based day of month.
        returns: New %OffsetDateTime with the specified day of month and its current year/month/time/offset.

      withDayOfWeek:
        signature: |
          (dayOfWeek: number | %DayOfWeek): %OffsetDateTime
        params:
          dayOfWeek: Day of week or its numeric value
        returns: New %OffsetDateTime with the specified day of week and its current week/time/offset.

      withDayOfYear:
        signature: |
          (dayOfYear: number): %OffsetDateTime
        params:
          dayOfYear: 1-based day of year.
        returns: New %OffsetDateTime with the specified day of year and its current year/time/offset.

      withHour:
        signature: |
          (hour: number): %OffsetDateTime
        params:
          hour: Hour of a day.
        returns: New %OffsetDateTime with the specified hour of a day. All other properties don't change.

      withMinute:
        signature: |
          (minute: number): %OffsetDateTime
        params:
          minute: Minute of an hour.
        returns: New %OffsetDateTime with the specified minute of an hour. All other properties don't change.

      withSecond:
        signature: |
          (second: number): %OffsetDateTime
        params:
          second: Second of a minute.
        returns: New %OffsetDateTime with the specified second of a minute. All other properties don't change.

      withMs:
        signature: |
          (ms: number): %OffsetDateTime
        params:
          ms: Millisecond of a second.
        returns: New %OffsetDateTime with the specified millisecond of a second. All other properties don't change.

      toString:
        signature: |
          (): string
        returns: String representation of the offset date/time in ISO format, such as "2019-12-30T18:30:15.225+03:00".

    staticMethods:
      ofInstant:
        signature: |
          (instant: %Instant, offset: %ZoneOffset): %OffsetDateTime
        params:
          instant: Instant.
          offset: Time zone offset.
        returns: New %OffsetDateTime representing %instant in %offset.

      ofDateTime:
        signature: |
          (localDateTime: %LocalDateTime, offset: %ZoneOffset): %OffsetDateTime
        params:
          localDateTime: Local date/time.
          offset: Time zone offset.
        returns: New %OffsetDateTime representing %dateTime in %offset.

      parse:
        signature: |
          (str: string): %OffsetDateTime throws %TemporalParsingError
        params:
          str: String representation of offset date/time in ISO format, such as '2019-12-30T18:30:15.225+03:00'.
        returns: '%OffsetDateTime representation.'

      compare:
        signature: |
          (x: %OffsetDateTime, y: %OffsetDateTime): number
        params:
          x: One offset date/time.
          y: Another offset date/time.
        returns: |
          <ul>
            <li>0 if this %x and %y are the same offset date/time;</li>
            <li>positive value if %x goes after %y;</li>
            <li>negative value if %x goes before %y.</li>
          </ul>
          The objects are first compared by instant, and then by offset.
          Null and undefined are considered less than anything, except each other.

      equal:
        signature: |
          (x: %OffsetDateTime, y: %OffsetDateTime): boolean
        params:
          x: One offset date/time.
          y: Another offset date/time.
        returns: |
          True if %x is equal to %y, i.e. all components are equal.
          Null and undefined are only equal to each other.
